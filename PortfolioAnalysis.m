% stocks = hist_stock_data(now-365,now,'SPY','T','VZ','GOOG','NFLX','FB','EBAY','SBUX','TSLA','NKE','AMZN','KO','CL','PEP','PG','WMT','XOM','EOG','KMI','CVX','WMB','MS','JPM','WFC','BAC','GS','CVS','PFE','JNJ','UNH','ANTM','BA','CAT','HON','FDX','NOC','MSFT','CSCO','MU','ADBE','NVDA','SHW','FMC','MOS','CF','LYB','CBRE','SPG','KIM','BXP','AVB','FE','NI','PPL','AEP','CMS')


%%
% My portfolio consists of 55 stocks from different sectors within S&P 500.
% Let's download the data from Yahoo Finance and organize it for our
% analysis.
s = struct(stocks);
Date = stocks.Date;
Ticker = {stocks.Ticker};
AdjClose = [stocks.AdjClose];
colNames = { 'SPY','T' 'VZ' 'GOOG' 'NFLX' 'FB' 'EBAY' 'SBUX' 'TSLA' 'NKE' 'AMZN' 'KO' 'CL' 'PEP' 'PG' 'WMT' 'XOM' 'EOG' 'KMI' 'CVX' 'WMB' 'MS' 'JPM' 'WFC' 'BAC' 'GS' 'CVS' 'PFE' 'JNJ' 'UNH' 'ANTM' 'BA' 'CAT' 'HON' 'FDX' 'NOC' 'MSFT' 'CSCO' 'MU' 'ADBE' 'NVDA' 'SHW' 'FMC' 'MOS' 'CF' 'LYB' 'CBRE' 'SPG' 'KIM' 'BXP' 'AVB' 'FE' 'NI' 'PPL' 'AEP' 'CMS'};
Table = array2table(AdjClose,'VariableNames',colNames);
Final_Table = [Date Table];
Final_Table.Var1 = datetime(Final_Table.Var1);
Final_Table.Properties.VariableNames{1} = 'Date';

%%
head(Final_Table,5)
%%
% In almost every case in investing, we need to evaluate the state of the
% economy to figure out which stocks will perfom better or worse during
% different periods. One simple way to do this is to calculate MACD. If you
% are interested in how we make different economic projections and modeling
% then check out Modeling the US economy.
% Let's find the state of the economy
% Calculate the leading and lagging moving averages and then calculate the MACD.
SPY = Final_Table.SPY;
movAvgShort = movavg(SPY,'exponential',12);      %lead of 3 samples
movAvgLong = movavg(SPY,'exponential',26);       % lead of 5 samples
MACD = movAvgShort - movAvgLong;

% If MACD >= 5 then momentum of the economy is up, if MACD <= 5, economy
% momentum is down and if MACK <5 and MACD >-5 then the economy is flat.
up = nnz(MACD >= 5);
up2020 = nnz( (year(Final_Table.Date) == 2020) & (MACD >= 5) );

% Let us create a column vector named econPerformance whose elements
% are 1 when the economy is up, -1 when the economy is down, and 0 otherwise.
econPerformance = zeros(length(MACD),1);
econPerformance(MACD >= 5) = 1;
econPerformance(MACD <= -5) = -1;

%Let's plot econPerformance and Date
plot(Final_Table.Date,econPerformance)
ylim([-2 2])
title("Economic Cycle")
xlabel("Months")
ylabel("Economic cycle")

% We can see from the graph that market experienced a lot of ups and downs
% during coronavirus pandemic.
%%
Final_Table.econPerformance = econPerformance;

%% Import data from text file
% Script for importing data from the following text file:
%
%    filename: C:\Users\kushk\OneDrive\Documents\FinancialEngineering\StockInfo.csv
%
% Auto-generated by MATLAB on 01-Jan-2021 08:21:28

%% Set up the Import Options and import the data
opts = delimitedTextImportOptions("NumVariables", 3);

% Specify range and delimiter
opts.DataLines = [2, Inf];
opts.Delimiter = ",";

% Specify column names and types
opts.VariableNames = ["StockTicker", "Sector", "Classification"];
opts.VariableTypes = ["string", "categorical", "string"];

% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";

% Specify variable properties
opts = setvaropts(opts, "StockTicker", "WhitespaceRule", "preserve");
opts = setvaropts(opts, ["StockTicker", "Sector", "Classification"], "EmptyFieldRule", "auto");

% Import the data
StockInfo = readtable("C:\Users\kushk\OneDrive\Documents\FinancialEngineering\StockInfo.csv", opts);


%% Clear temporary variables
clear opts

%%
% Examine the variables in StockInfo - the momentum on Feb-27-2020 is -1 i.e., 'down'
% Calculate the economy's performance for a specific date
dateOfInterest = datetime([2020 02 28]);
performanceAllDates = Final_Table.econPerformance;
performance = performanceAllDates(Final_Table.Date == dateOfInterest);

% If performance is equal to -1, extract the stock tickers of all the 'downcycle' tickers
% If performance is 1 and if it is, extract the stock tickers of all the 'upcycle' tickers.
if performance == 1
   upcycleIdx = strcmp(stockInfo.Classification,'upcycle');
   stocksToBuy = stockInfo{upcycleIdx,'StockTicker'};
elseif performance == -1
   downcycleIdx = strcmp(StockInfo.Classification,'downcycle');
   stocksToBuy = StockInfo{downcycleIdx,'StockTicker'};
end

% Calculate the VaR by using function calculateVaR of each of the stocks
for i=1:length(stocksToBuy);
   stockTicker = stocksToBuy{i};
   var5(i) = calculateVaR(Final_Table{:,stockTicker});
end

% Find the stock with minimum VaR
[minValue,idx] = min(-var5);
minVaRStock = stocksToBuy{idx};

%%
%  Our analysis suggests us to buy WMT. Now, let us visualize the change 
% in correlation over time. between SPY & WMT.
SP = Final_Table.SPY;
WM = Final_Table.WMT;

% Concatenate the vectors CM and SP horizontally. 
% Use the function tick2ret with the matrix index as input
% to convert the index values to returns. 

index = [WM SP];
indexRetns = tick2ret(index);


% Compute the correlation of the 2 columns of the matrix indexRetns
% using the function corr. The corr function outputs a matrix.
% Extract the correlation coefficient from the output matrix,
cm = corr(indexRetns);
c = cm(1,2);

% Write a 'for loop' to compute the correlation of 15 elements at a time.
% Store the correlation coefficients in a vector called rollingCorr.
                    
windowSize = 15;
numRecords = size(indexRetns,1);
for k = 1:(numRecords - windowSize + 1);
   rollingCorrMatrix = corr(indexRetns(k:k+windowSize-1,:)); 
   rollingCorr(k) = rollingCorrMatrix(1,2);
end
%%
% Let us plot VaR at 5% for CMS

%% Calculate Returns
% Using GBM formula, we can predict multiple paths of the future stock
% prices of WMT. The formula for GBM is 
%% 
% $S(T + deltaT) = S(T)*exp((mu-sigma^2/2)*deltaT
% + sigma*epsilon*sqrt(deltaT))$ ;
data = Final_Table(:,16);
data = data{:,:};      %Converting table to array
logPrices = log(data);

% Calculate CMS returns
returns = diff(logPrices);

%% Calculating factors of GBM
% Calculate the descriptive statistics

% Compute mu
mu = mean(returns);

% compute sigma
sigma = std(returns);

% Assign deltaT = 1
deltaT = 1;

%% Calculate the future prices
% Now create a vector of normally distributed numbers for epsilon.
% Simulating 100 future paths of stock price for WMT.
epsilon = randn(22,100);

%% Create factors for GBM
factors = exp((mu-sigma^2/2)*deltaT + sigma*epsilon*sqrt(deltaT));

%%
% To predict the future values of the stock price, first we need to extract 
% the price of WMT on the last trading day and store the results.
S0 = data(end,1);

%%
% Create a row vector of size 1 by 100 such that each element of the vector
% has the value equal to the last recorded stock price S0. Note:If you
% change epsilon to 200, you need to change this vector too.
lastPriceVector = ones(1,100)*S0;

%%
% Now concatenate lastPriceVector and factors
factors2 = [lastPriceVector;factors];

%%
% Functions like cumprod are applied to each column of the input matrix
% Use the function cumprod with factors 2 as the input to compute the
% prices at future time instants
paths = cumprod(factors2);

%% Plot the paths
% Plot paths to see the predicted prices of WMT
plot(paths)
xlabel("Time (Days)")
ylabel("Prices")
title("Simulated Future Paths of CMS")

%%
% Combine stock price and predicted path together
plot(data)
xlabel("Time")
ylabel("Stock Price")
title("Stock Price over last 128 Days")
hold on

%%
% The future prices should have x-data that represents the future time
% points. Since the historical data contains 252 records, the future value
% should be plotted against the index(x-data)
plot(243:265,paths)
xlabel("Time")
ylabel("Stock Price")
title("Historical Stock Prices & Simulated Prices")
hold off

%%
% Zoom in the graph by changing the axis limit
xlim([200 270])

%%
% Extract all rows and columns from paths
finalPrices = paths(end,:);

%%
% Calculate possible returns
possibleReturns = log(finalPrices) - log(S0);

%%
% Plot a histogram of the possible returns with 20 bins.
histogram(possibleReturns,20)
xlabel("Standard Deviation")
ylabel("Possible Returns")
title("Possible Returns Histogram")

%%
% Calculate the VaR
var5 = prctile(possibleReturns,5);
hold on
plot([var5 var5],[0 20], 'r')
title("Value at Risk at 5%")
hold off

%%
% % Let's plot a regression line against SPY

Final_Table.days = days(datetime(Final_Table.Date)-datetime(Final_Table.Date(1)));
SPYfit = fitlm(Final_Table,'PredictorVars','days','ResponseVar','SPY')
d = Final_Table.days;
SPYfit1 = fitlm([d d.^2 d.^3],SPY)
properties(SPYfit1)
c = SPYfit1.Coefficients
R_squared = SPYfit1.Rsquared
formula = SPYfit1.Formula
%%
%Plotting
plot(d,SPY)
hold on
plot(d,SPYfit1.Fitted,'g')
xlabel("Time")
ylabel("Price")

%%
%Lets find the predicted SPY index values for the first 200 days using
%SPYfit.
SPY = log(Final_Table.SPY);
day = Final_Table.days;
dates = Final_Table.Date;
SPYfit3 = fitlm(day,SPY);
plot(day,SPY)
hold on
plot(d,SPYfit3.Fitted,'g')
y = predict(SPYfit3,(250:400)'); 
plot(250:400,y,'r:')

%% REsiduals
plotResiduals(SPYfit3)
plotResiduals(SPYfit3,'fitted')
plotResiduals(SPYfit3,'probability')

%%
% Make residual table
resTable = SPYfit3.Residuals;
% Create a numeric array containing the raw data from residual table
res = resTable.Raw;
% Let's apply Lilliefors normality test on raw residual data.
[hLil,pLil] = lillietest(res)

% Since hLil value is 1, test rejects null hypothesis that the data comes
% from the normal distribution. Smaller p-value also supports the rejection
% of the null hypothesis

% Le'ts try Jarque-Bera normality test on the raw residuals.
[hJB,pLil] = jbtest(res)

% We are confident from these tests that residuals do not have normal
% distribution.

%%
% Let's evaluate the goodness of fit
% Diagnostics plots helps us identify outliers and different problems with
% out fit.
plotDiagnostics(SPYfit3)
plotDiagnostics(SPYfit3,'covratio')

%Cook's distance is a common way to determine outliers.
plotDiagnostics(SPYfit3,'cookd')

% Let's create diagnostic table
diagTable = SPYfit3.Diagnostics;

% Lets create numeric array containing CooksDistance
ckd = diagTable.CooksDistance;

%%
% Let's visualize the raw data with variables color coded according to Cook's distance.
scatter(Final_Table.days,Final_Table.SPY,30,ckd,'filled');
colorbar

%% Parametric Fitting
% Fit Distribution
SPYreturns = diff(SPY);
ndo = fitdist(SPYreturns,'Normal');
tFit = fitdist(SPYreturns,'tLocationScale')

% Hold the parameter values property of t Location-Scale probability
% distribution object
msn = tFit.ParameterValues;

% Determine the inverse cdf value of the fit.
paramVaR99 = icdf(tFit,0.01)
%%
%Plotting Distributions
binEdges = -0.05:0.005:0.05;
histogram(SPYreturns,binEdges,'Normalization','pdf')
% Assigning the property of Normalization to the values of pdf will
% normalize the height of each var so the sum of bar areas equals 1

%Let's create a vector that starts at -0.05 and goes to 0.05
rq = -0.05:0.001:0.05;

% Let's use pdf function to determine pdf value of the fit
p = pdf(tFit,rq);

%Plot the pdf against rq.
hold on
plot(rq,p,'r')
hold off

%%

% Let's use SPY returns to create t Location-Scale probability distribution
% object and using this fit, generate the random numbers.

%% Import data and compute returns
Final_Table.Date = datetime(Final_Table.Date);
dys = days(datetime(Final_Table.Date) - datetime(Final_Table.Date(1)));
SPYreturns = tick2ret(Final_Table.SPY,dys);

%% Fit a t scale-location distribution
tFit = fitdist(SPYreturns,'tlocationscale');

%% Monte-Carlo Simulations for a t distribution
nSteps = 90;       % Number of steps into the future
nExp = 5e3;        % Number of random experiments to run

%% Modify simReturns to generate random numbers from the fit
simReturns = random(tFit,nSteps,nExp);

predictions = ret2tick(simReturns,Final_Table.SPY(end));
quantileCurves = quantile(predictions,[0.01 0.05 0.5 0.95 0.99],2);

%% Plot the returns
figure
subplot(2,1,1)
plot(Final_Table.Date,Final_Table.SPY,'LineWidth',2)
title('SPY Closing Value')
xlabel('Date')
grid on
hold on
plot(Final_Table.Date(end) + (0:nSteps),quantileCurves,'r')
legend('Historical Data','Future Predictions','Location','NW')
hold off

subplot(2,1,2)
histogram(predictions(end,:),'Normalization','pdf')
xlabel('SPY Closing Value')
title('Distribution of Simulated Values at April 30, 2021')
xlim([0 1000])

%% marketModel
% Predicting Market Movement based on stocks on our portfolio

%% Import the data
ReturnTable = tick2ret(Final_Table(:,[2:57]));
dates = Final_Table.Date(1:end-1,:);

%% Create a matrix of factors and a vector with the market returns
factors = ReturnTable{:,2:end};
market = ReturnTable{:,1};
marketModelObject = fitlm(factors,market);

%% Plot the data
plot(dates,market,'b')
hold on
plot(dates,marketModelObject.Fitted,'r')
grid
title('Market Returns and Fitted Values')









